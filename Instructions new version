public class Instructions {
	protected int Opcode[] = new int[6];
	protected int R[] = new int[2];
	protected int IX[] = new int[2];
	protected int I = 0;
	protected int Instruction[] = new int[16];
	protected int Address[] = new int[5];
	protected int effectiveAdd = 0;
	protected int immediate = 0;
	
	public int getImmediate() {
		return immediate;
	}

	public void setImmediate(int immediate) {
		this.immediate = immediate;
	}

	CPU cp = new CPU();
	SimpleMemory SM = new SimpleMemory();
	
	public int getdecimalvalue(int[] data){
		int decimaldata = 0;
		for(int i = 0; i < data.length;i++){
			decimaldata += data[i]*(Math.pow(2, i));//get memory address from pc
		}
		return decimaldata;
	}
	
	public int[] getBinaryValue(int data){
		int binary[] = new int[16];
	     int index = 0;
	     while(data > 0){
	       binary[index++] = data%2;
	       data = data/2;
	     }
	     for(int i = index-1;i >= 0;i--){
	       System.out.print(binary[i]);
	     }
		return binary;
	}

	public int[] fetchInstruction(){
		//SM.memory[6]=31;
		int InsAdd = 0;
		int valueinside[] = new int[16];//=instruction
		InsAdd = getdecimalvalue(cp.PC.data);
		valueinside = SM.memory[InsAdd];
		return valueinside;
}
	
	public int[] fetchInstruction(int data[]){
		int InsAdd = 0;
		int valueinside[] = new int[16];//=instruction
		InsAdd = getdecimalvalue(data);
		valueinside = SM.memory[InsAdd];	
		return valueinside;
	}
	
	public void decodeInstruction(){
		int InstructionContent[] = new int[16];
		InstructionContent = fetchInstruction(); 
		for(int i =0; i < Opcode.length; i++){
		Opcode[i] = InstructionContent[i];
		}
		R[1] = InstructionContent[6];
		R[0] = InstructionContent[7];
		IX[1] = InstructionContent[8];
		IX[0] = InstructionContent[9];
		I = InstructionContent[10];
		for(int i =0; i < Address.length; i++){
			Address[i] = InstructionContent[i+11];
			}
	}
	
	public int calculateDirect(int Address[],int registerindex[]){
		int sumAddress = 0;
		int sumIndex = 0;
		int sum = 0;
		sumAddress = getdecimalvalue(Address);
		sumIndex = getdecimalvalue(registerindex);
		sum = sumIndex + sumAddress;
		return sum;
	}

	public int calculateInDirect(int Address[]){
		int sumAddress = 0;
		int indirectAddress[] = new int[16];
		int sum = 0;
		sumAddress = getdecimalvalue(Address);
		indirectAddress = SM.memory[sumAddress];
		sum = getdecimalvalue(indirectAddress);
		return sum;
	}

	public int calculateInDirect(int Address[],int registerindex[]){
		int sumAddress = 0;
		int indirectAddress = 0;
		int sumIndex = 0;
		int sum = 0;
		sumAddress = getdecimalvalue(Address);
		indirectAddress = getdecimalvalue(SM.memory[sumAddress]);
		sumIndex = getdecimalvalue(registerindex);
		sum = sumIndex + indirectAddress;
		return sum;
	}

	public void EffectiveAddress(){
		if(I == 0){//direct addressing
			if(IX[0]==0 && IX[1]==0){
				System.out.println("direct addressing 0");
					effectiveAdd = getdecimalvalue(Address);
			}
			
			else if (IX[0]==1 && IX[1] == 0){//x1
				System.out.println("direct addressing 1");
				effectiveAdd = calculateDirect(Address,cp.X1.data);
			}
			else if(IX[0]==0 && IX[1] == 1){//x2
				System.out.println("direct addressing 2");
				effectiveAdd = calculateDirect(Address,cp.X2.data);
			}
			else if(IX[0]==1 && IX[1] == 1){//x3
				System.out.println("direct addressing 3");
				effectiveAdd = calculateDirect(Address,cp.X3.data);
			}
		}
		else if(I == 1){
			if(IX[0]==0 && IX[1]==0){
				System.out.println("indirect addressing 0");
				effectiveAdd = calculateInDirect(Address);
			}
			else if (IX[0]==1 && IX[1] == 0){//x1
				System.out.println("indirect addressing 1");
				effectiveAdd = calculateInDirect(Address,cp.X1.data);
			}
			else if(IX[0]==0 && IX[1] == 1){//x2
				System.out.println("indirect addressing 2");
				effectiveAdd = calculateInDirect(Address,cp.X2.data);
			}
			else if(IX[0]==1 && IX[1] == 1){//x3
				System.out.println("indirect addressing 3");
				effectiveAdd = calculateInDirect(Address,cp.X3.data);
			}
		}
	}
	
	public void LDR(){//Load register from memory  if opcode==01
		System.out.println("LDR");
		
		int indexofR = R[0]+R[1]*2;
		int contentofEA[] = new int[16];
		int ccontentofEA[] = new int[16];
		int addresscontentofEA = 0;
		contentofEA = SM.memory[effectiveAdd];
		addresscontentofEA = getdecimalvalue(contentofEA);
		ccontentofEA = SM.memory[addresscontentofEA];
		if(I == 0){
			if(indexofR == 0)     cp.R0.data = contentofEA;
			else if(indexofR==1)  cp.R1.data = contentofEA;
			else if(indexofR==2)  cp.R2.data = contentofEA;
			else if(indexofR==3)  cp.R3.data = contentofEA;
		}
		else{
			if(indexofR == 0)    cp.R0.data = ccontentofEA;
			else if(indexofR==1) cp.R1.data = ccontentofEA;
			else if(indexofR==2) cp.R2.data = ccontentofEA;
			else if(indexofR==3) cp.R3.data = ccontentofEA;
		}
	}
	
	public void STR(){//store register to memory if opcode == 02
		System.out.println("STR");
		
		int indexofR = R[0]+R[1]*2;
		int contentofEA[] = new int[16];
		int concontentofEA[] = new int[16];
		contentofEA = SM.memory[effectiveAdd];
		int addresscontentofEA = 0;
		addresscontentofEA = getdecimalvalue(contentofEA);
		concontentofEA = SM.memory[addresscontentofEA];
		if(I == 0){
			if(indexofR == 0)     contentofEA = cp.R0.data;
			else if(indexofR==1)  contentofEA = cp.R1.data;
			else if(indexofR==2)  contentofEA = cp.R2.data;
			else if(indexofR==3)  contentofEA = cp.R3.data;
		}
		else{
			if(indexofR == 0)    concontentofEA = cp.R0.data;
			else if(indexofR==1) concontentofEA = cp.R1.data;
			else if(indexofR==2) concontentofEA = cp.R2.data;
			else if(indexofR==3) concontentofEA = cp.R3.data;
		}
	}
	
	public void LDA(){//load register with address opcode == 03
		System.out.println("LDA");
		
		int indexofR = R[0]+R[1]*2;
		int EA[] = new int[16];
		EA = getBinaryValue(effectiveAdd);
		int contentofEA[] = new int[16];
		contentofEA = SM.memory[effectiveAdd];
		
		if(I == 0){
			if(indexofR == 0)     cp.R0.data = EA;
			else if(indexofR==1)  cp.R1.data = EA;
			else if(indexofR==2)  cp.R2.data = EA;
			else if(indexofR==3)  cp.R3.data = EA;
		}
		else{
			if(indexofR == 0)    cp.R0.data = contentofEA;
			else if(indexofR==1) cp.R1.data = contentofEA;
			else if(indexofR==2) cp.R2.data = contentofEA;
			else if(indexofR==3) cp.R3.data = contentofEA;
		}
	}
	
	public void LDX(){//LOAD INDEX REGISTER FROM MEMORY 41
		System.out.println("LDX");
		
		int indexofX = IX[0]+IX[1]*2;
		int contentofEA[] = new int[16];
		contentofEA = SM.memory[effectiveAdd];
		if(indexofX==1)       cp.X1.data = contentofEA;
		else if(indexofX==2)  cp.X2.data = contentofEA;
		else if(indexofX==3)  cp.X3.data = contentofEA;
	}
	
	public void STX(){//STORE INDEX REGISTER TO MEMORY     have error here
		System.out.println("STX");
		
		int indexofX = IX[0]+IX[1]*2;
		if(I == 0){
			
		}
		else if(I==1){
		int contentofEA[] = new int[16];
		contentofEA = SM.memory[effectiveAdd];
		if(indexofX==1)       contentofEA = cp.X1.data;
		else if(indexofX==2)  contentofEA = cp.X2.data;
		else if(indexofX==3)  contentofEA = cp.X3.data;
		}	
	}
	
	public void AMR(){
		int indexofR = R[0]+R[1]*2;
		int r0 = getdecimalvalue(cp.R0.data);
		int r1 = getdecimalvalue(cp.R1.data);
		int r2 = getdecimalvalue(cp.R2.data);
		int r3 = getdecimalvalue(cp.R3.data);
		int contentofEA[] = new int[16];
		contentofEA = SM.memory[effectiveAdd];
		int decimalcontentofEA = getdecimalvalue(contentofEA);
		int sum0 = r0 + decimalcontentofEA;
		int sum1 = r1 + decimalcontentofEA;
		int sum2 = r2 + decimalcontentofEA;
		int sum3 = r3 + decimalcontentofEA;
		if(indexofR == 0)    cp.R0.data = getBinaryValue(sum0);
		else if(indexofR==1) cp.R1.data = getBinaryValue(sum1);
		else if(indexofR==2) cp.R2.data = getBinaryValue(sum2);
		else if(indexofR==3) cp.R3.data = getBinaryValue(sum3);
	}
	
	public void SMR(){
		int indexofR = R[0]+R[1]*2;
		int r0 = getdecimalvalue(cp.R0.data);
		int r1 = getdecimalvalue(cp.R1.data);
		int r2 = getdecimalvalue(cp.R2.data);
		int r3 = getdecimalvalue(cp.R3.data);
		int contentofEA[] = new int[16];
		contentofEA = SM.memory[effectiveAdd];
		int decimalcontentofEA = getdecimalvalue(contentofEA);
		int sum0 = r0 - decimalcontentofEA;
		int sum1 = r1 - decimalcontentofEA;
		int sum2 = r2 - decimalcontentofEA;
		int sum3 = r3 - decimalcontentofEA;
		if(indexofR == 0)    cp.R0.data = getBinaryValue(sum0);
		else if(indexofR==1) cp.R1.data = getBinaryValue(sum1);
		else if(indexofR==2) cp.R2.data = getBinaryValue(sum2);
		else if(indexofR==3) cp.R3.data = getBinaryValue(sum3);
		
	}
	
	public void AIR(int immed){
		if(immed == 0){}
		else{
		int indexofR = R[0]+R[1]*2;
		int r0 = getdecimalvalue(cp.R0.data);
		int r1 = getdecimalvalue(cp.R1.data);
		int r2 = getdecimalvalue(cp.R2.data);
		int r3 = getdecimalvalue(cp.R3.data);
		int sum0 = r0 + immed;
		int sum1 = r1 + immed;
		int sum2 = r2 + immed;
		int sum3 = r3 + immed;
		if(indexofR == 0)    cp.R0.data = getBinaryValue(sum0);
		else if(indexofR==1) cp.R1.data = getBinaryValue(sum1);
		else if(indexofR==2) cp.R2.data = getBinaryValue(sum2);
		else if(indexofR==3) cp.R3.data = getBinaryValue(sum3);
		}
	}
	
	public void SIR(int immed){
		if(immed == 0){}
		else{
		int indexofR = R[0]+R[1]*2;
		int r0 = getdecimalvalue(cp.R0.data);
		int r1 = getdecimalvalue(cp.R1.data);
		int r2 = getdecimalvalue(cp.R2.data);
		int r3 = getdecimalvalue(cp.R3.data);
		int sum0 = r0 - immed;
		int sum1 = r1 - immed;
		int sum2 = r2 - immed;
		int sum3 = r3 - immed;
		if(indexofR == 0)    cp.R0.data = getBinaryValue(sum0);
		else if(indexofR==1) cp.R1.data = getBinaryValue(sum1);
		else if(indexofR==2) cp.R2.data = getBinaryValue(sum2);
		else if(indexofR==3) cp.R3.data = getBinaryValue(sum3);
		}
	}
	
	public void excuteInstruction(){
		switch (getdecimalvalue(Opcode)) {
        case 1:  LDR();
                 break;
        case 2:  STR();
                 break;
        case 3:  LDA();
                 break;
        case 4:  AMR();
                 break;
        case 5:  SMR();
                 break;
        case 6:  AIR(getImmediate());
                 break;
        case 7:  SIR(getImmediate());
                 break;
        case 41: LDX();
                 break;
        case 42: STX();
                 break;
        default: 
                 break;
    }
		
	}
}
